<?php

//$host = 'probatv.ru';
//$host = 'kwinflat.ru';
$host = 'ittve.me';
//$host = 'localhost';
//$host = "127.0.0.1";

// $ports = array(21, 25, 80, 81, 90, 110, 143, 443, 587, 2525, 3306);
$ports = array(21,80,90,7776,7777);

// Сканер портов на PHP
// http://codeserfer.com/250-skaner-portov-na-php.html

// Что представляет собой сканер портов на PHP? Чтобы узнать, открыт порт или нет, 
// необходимо попытаться к нему подключиться. Если подключение произошло удачно, 
// то на удаленном сервере какая-либо служба открыла этот порт в ожидании подключений.
// Если подключение неудачно, то порт закрыт. 

// Чтобы остаться невидимым, чаще всего взломщик захватывает какой-либо Web-сервер 
// в Интернете, устанавливает на него свой сценарий и производит сканирование с 
// этого сервера, оставаясь при этом анонимным. 

/*
echo "<br>";
foreach ($ports as $port)
{
  $s=socket_create(AF_INET, SOCK_STREAM, 0);
  $res=@socket_connect($s, $host , $port);
  if ($res) echo ("$port: Порт открыт<br>");
  else echo      ("$port: Порт не отвечает<br>");
}
*/

// Что происходит в сценарии. Запускаем цикл. Внутри цикла создается сокет 
// с помощью функции socket_create(). Сканироваться будут порты интернет протокола TCP, 
// поэтому в качестве первого параметра передаем AF_INET (указывает на необходимость 
// использования интернет-протокола). Второй параметр равен SOCK_STREAM, ЧТО соответствует 
// семейству протоколов TCP Третий параметр обнулен. На следующем этапе пытаемся 
// соединиться с портом $i с помощью функции socket_connect(). Если соединение невозможно,
// то функция вернет ошибку, которая будет отображена на форме. Чтобы подавить сообщение 
// об ошибке, перед именем функции поставим символ @ Результат выполнения функции 
// сохраняется в переменной $res. Теперь проверим результат. Если он равен true, 
// то порт открыт, поэтому выводим на экран соответствующее сообщение. 

// Вы должны учитывать, что такое сканирование далеко не всегда верно. Крупные сайты 
// имеют достаточно интеллектуальные средства предотвращения сканирования.

// Усложним задачу. Давайте сделаем так, чтобы IP-адрес определялся в коде сценария, 
// т.е. чтобы пользователь мог передавать имя сайта. Помимо этого, будем отображать 
// не только номер открытого порта, но и его имя.

/*
echo "<br>";
$host_ip = gethostbyname($host);
echo $host.' '.$host_ip."<br>";

foreach ($ports as $port)
{
  $s=socket_create(AF_INET, SOCK_STREAM, 0 );
  $res=@socket_connect($s, $host_ip, $port);
  if ($res)
  {
    $portname=getservbyport($port, "tcp");
    echo ("$port: Порт открыт ($portname)<br>");
  }
  else echo ("$port: Порт не отвечает<br>");
}
*/

// В этом примере, прежде чем выполнять цикл, мы определяем IP-адрес указанного 
// компьютера с помощью функции gethostbyname(). Если пользователь укажет не имя 
// компьютера, а его адрес, то функция ничего преобразовывать не будет, а просто 
// вернет этот же IP. Так как мы в цикле соединяемся с одним и тем же компьютером, 
// то чтобы не определять имя на каждом шаге, вызов функции gethostbynameo вынесен 
// за пределы цикла. Когда найден открытый порт, мы определяем его имя с помощью 
// функции getservbyport(). Этой функции передается номер найденного порта и имя 
// протокола tcp, потому что мы сканируем именно эти порты.

// Далее сканер UDP-портов, тут всего два отличия от ТСР-сканирования:
// у функции socket_create() второй параметр равен SOCK_DGRAM, что соответствует 
// UDP-протоколу, при определении имени службы у функции getservbyport() 
// второй параметр равен udp.

/*
echo "<br>";
$host_ip = gethostbyname($host);
echo $host.' '.$host_ip." [UDP] <br>";
foreach ($ports as $port)
{
  $s=socket_create(AF_INET, SOCK_DGRAM, 0 );
  $res=@socket_connect($s, $host_ip, $port);
  if ($res)
  {
    $portname=getservbyport($port, "udp");
    echo ("$port: Порт открыт ($portname)<br>");
  }
  else echo ("$port: Порт не отвечает<br>");
}
*/

// Наш сканер портов не оптимизирован. Каждый раз в цикле создается сокет с помощью 
// функции socket_create(). Это отнимает лишние ресурсы сервера и время, а ведь сокет 
// нужно создавать до начала цикла и после успешного соединения с сервером. Если 
// соединение прошло неудачно, то можно без вызова socket_create() пытаться подключиться 
// на другой порт. 

// Вот оптимизированный вариант сканирования:
echo "<br>";
$host_ip = gethostbyname($host);
echo $host.' '.$host_ip."<br>";

$s=socket_create(AF_INET, SOCK_STREAM, 0 );
foreach ($ports as $port)
{
  $res=@socket_connect($s, $host_ip, $port);
  if ($res)
  {
    $portname=getservbyport($port, "tcp");
    echo ("$port: Порт открыт ($portname)<br>");
    $s=socket_create(AF_INET, SOCK_STREAM, 0 );
  }
  else echo ("$port: Порт не отвечает<br>");
}

// https://gist.github.com/akalongman/b50bc11a9303adb6f2db

ini_set('max_execution_time', 0);
ini_set('memory_limit', -1);

echo "<br>";
foreach ($ports as $port)
{
   echo $host.':'.$port;
   $connection = @fsockopen($host, $port, $errno, $errstr, 2);
   if (is_resource($connection))
   {
      echo ' => ('.getservbyport($port,'tcp').') открыт<br>';
      fclose($connection);
    }
    else
    {
      echo ' => не отвечает<br>';
    }
}












