/** Arduino Pro Mini                                    *** Walk_Sounds.cpp ***
 * 
 * Библиотека звуковых вставок в приложение 
 * (на основе https://github.com/robsoncouto/arduino-songs)
 * 
 * v1.1, 22.08.2024                                   Автор:      Труфанов В.Е.
 * Copyright © 2024 tve                               Дата создания: 19.08.2024
**/

#include "Walk_Sounds.h"

// ****************************************************************************
// *      Воспроизвести музыкальный фрагмент по указанному массиву звуков     *
// *                            с заданным темпом                             *
// ****************************************************************************
void WalkSounds::Soundi(int *Melody, int MelodySize, int OneSize, int tempo = 132)
{
   // Определяем размер (количество байт) мелодии
   int notes = MelodySize / OneSize / 2;
   // Назначаем темп мелодии
   int wholenote = (60000 * 4) / tempo;
   // Инициализируем позицию текущей ноты
   int divider = 0;
   // Инициализируем продолжительность ноты
   int noteDuration = 0;
   // Перебираем ноты мелодии, помня что массив включает пары: ноты + длительности
   for (int thisNote = 0; thisNote < notes * 2; thisNote = thisNote + 2) 
   {
      // Вычисляем длительность текущей ноты
      divider = Melody[thisNote + 1];
      if (divider > 0) 
      {
         noteDuration = wholenote / divider;
      } 
      // Уточняем длительность для ноты с точкой
      else if (divider < 0) 
      {
         noteDuration = wholenote / abs(divider);
         noteDuration *= 1.5; 
      }
      else {}
      // Воспроизводим ноту только в течение 90% ее продолжительности, 
      // оставляя 10% в качестве паузы
      tone(buzzer, Melody[thisNote], noteDuration * 0.9);
      // Выдерживаем время продолжительности текущей ноты, 
      // прежде чем играть следующую ноту
      delay(noteDuration);
      // Останавливаем генерацию сигнала перед следующей нотой
      noTone(buzzer);
   }
}




// ****************************************************************************
// *         Управлять скоростью мотора и направлением его вращения           *
// ****************************************************************************


/*
void WalkSounds::Soundi(int x[], int ssize) 
{
 
   // Определяем размер мелодии исходя из того, что каждое целое состоит из двух байт (16 бит), а
   // на каждую ноту приходится два значения (высота тона и длительность), то есть
   // четыре байта
   notes = ssize / 2;
   // Определяем продолжительность всей ноты (темп) в мс
   int wholenote = (60000 * 4) / tempo;
   // Инициируем позицию текущей ноты и длительность 
   int divider = 0, noteDuration = 0;
   // Перебираем ноты мелодии, помня что массив включает пары: ноты + длительности
   for (int thisNote = 0; thisNote < notes * 2; thisNote = thisNote + 2) 
   {
      // Вычисляем длительность текущей ноты
      divider = x[thisNote + 1];
      if (divider > 0) 
      {
         noteDuration = (wholenote) / divider;
      } 
      else if (divider < 0) 
      {
         // Уточняем длительность для ноты с точкой
         noteDuration = (wholenote) / abs(divider);
         noteDuration *= 1.5; // increases the duration in half for dotted notes
      }
      // Воспроизводим ноту только в течение 90% ее продолжительности, оставляя 
      // 10% в качестве паузы
      tone(buzzer, x[thisNote], noteDuration * 0.9);
      // Выдерживаем время продолжительности текущей ноты, прежде чем 
      // играть следующую ноту
      delay(noteDuration);
      // Останавливаем генерацию сигнала перед следующей нотой
      noTone(buzzer);
   }
  
}
*/
//void WalkSounds::Sound() 
//{



   /*
   // Определяем размер мелодии исходя из того, что каждое целое состоит из двух байт (16 бит), а
   // на каждую ноту приходится два значения (высота тона и длительность), то есть
   // четыре байта
   notes = sizeof(Baby_Elephant_Walk) / sizeof(Baby_Elephant_Walk[0]) / 2;
   // Определяем продолжительность всей ноты (темп) в мс
   int wholenote = (60000 * 4) / tempo;
   // Инициируем позицию текущей ноты и длительность 
   int divider = 0, noteDuration = 0;
   // Перебираем ноты мелодии, помня что массив включает пары: ноты + длительности
   for (int thisNote = 0; thisNote < notes * 2; thisNote = thisNote + 2) 
   {
      // Вычисляем длительность текущей ноты
      divider = Baby_Elephant_Walk[thisNote + 1];
      if (divider > 0) 
      {
         noteDuration = (wholenote) / divider;
      } 
      else if (divider < 0) 
      {
         // Уточняем длительность для ноты с точкой
         noteDuration = (wholenote) / abs(divider);
         noteDuration *= 1.5; // increases the duration in half for dotted notes
      }
      // Воспроизводим ноту только в течение 90% ее продолжительности, оставляя 
      // 10% в качестве паузы
      tone(buzzer, Baby_Elephant_Walk[thisNote], noteDuration * 0.9);
      // Выдерживаем время продолжительности текущей ноты, прежде чем 
      // играть следующую ноту
      delay(noteDuration);
      // Останавливаем генерацию сигнала перед следующей нотой
      noTone(buzzer);
   }
   */
//}

// ****************************************************************************
// *                            Протестировать мотор                          *
// *            (метод запускается из цикла с интервалом в 1 сек,             *
// *                    когда поступает команда с ИК пульта)                  *
// ****************************************************************************
/*
// Определяем счетчик секунд теста и матрицу тестирования двигателя.
// В тесте на каждую скорость выделяется 5 секунд. В матрице указывается 
// с какой секунды теста запускается указанная скорость.
int incTest;
byte maxColTest=14;
byte maxSecTest=70; 
int tblTest[70][2] = {{0,600},{5,700},{10,800},{15,900},{20,1000},{25,1100},{30,512},{35,412},{40,312},{45,212},{50,112},{55,12},{60,-12},{65,512}};
*/

//void WalkSounds::Test()
//{
//  delay(10);
//} 

// ******************************************************** Walk_Sounds.cpp ***
