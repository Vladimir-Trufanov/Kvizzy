/** Arduino-Esp32-CAM                             *** ex5-1-33_Watchdog.ino ***
 * 
 *            Учебный пример таймера сторожевого механизма в ESP32 board 5.1.33
 *                                        (на контроллере AI-Thinker ESP32-CAM)
 * 
 * v1.1, 12.10.2024                                   Автор:      Труфанов В.Е.
 * Copyright © 2024 tve                               Дата создания: 12.10.2024
 * 
 * Таймер сторожевого механизма в ESP32 board >3.0x сильно отличается от предыдущей
 * реализации. Скетч представляет пример его реализации в Arduino IDE.
 * 
 * Документация последней версии:
 * https://docs.espressif.com/projects/esp-idf/en/v5.3.1/esp32/api-reference/system/wdts.html
 * 
 * WDT  - сторожевой таймер
 * IWDT - сторожевой таймер прерываний
 * TWDT - сторожевой таймер задач
 * 
 * Ключевой момент — установить задержку минимум в 1 мс после выполнения 
 * esp_task_wdt_reset:
 * 
 *    esp_task_wdt_reset();
 *    delay(1);  
 * 
 * Замечания:
 * - время ожидания установлено на 25 секунд
 * - в цикле 20 секунд. Сброс выполняется в течение первых 10 секунд, затем в течение 10 секунд сброс не выполняется.
 * - после 60 секунд без сброса система "выйдет из строя" и перезапустится через 75 секунд.
**/

#include <esp_task_wdt.h>

#define WDT_TIMEOUT 25   // тайм-аут в секундах
esp_err_t ESP32_ERROR;   // возвращенное значение при инициализации TWDT
int i = 0;               // счетчик циклов 
int last = millis();     // текущее время (уходящее в прошлое)

// ****************************************************************************
// *       Выполнить общие настройки и настройки сторожевого механизма        *
// ****************************************************************************
void setup() 
{
   Serial.begin(115200);
   delay(100);
   Serial.println("Конфигурируется WDT ...");
   Serial.print("Устанавливается Watchdog Timeout (в сек): ");
   Serial.println(WDT_TIMEOUT);
   
   // Отменяем подписку на незанятые задачи и деинициализируем таймер отслеживания задач TWDT
   // (эта функция деинициализирует TWDT и отменяет подписку на любые незавершенные задачи. 
   // Вызов этой функции, когда другие задачи все еще подписаны на TWDT, 
   // или когда WDT уже деинициализирован, приведет к возвращению кода ошибки.
   // Esp_task_wdt_deinit() не должна вызываться несколькими задачами одновременно.
   // Возврат: ESP_OK: TWDT успешно деинициализирован, другое: не удалось деинициализировать TWDT)
   esp_task_wdt_deinit();
   
   // Конфигурируем структуру таймера контроля задач (TWDT):
   // uint32_t timeout_ms     - длительность тайм-аута TWDT в миллисекундах
   // uint32_t idle_core_mask - битовая маска ядер контроллераа, 
   //    простой которых должен быть подписан при инициализации, где 1 << i 
   //    означает, что задача простоя ядра i будет отслеживаться TWDT
   // bool trigger_panic - вызов паники (перезагрузки) при наступлении тайм-аута
   esp_task_wdt_config_t wdt_config = 
   {
      .timeout_ms = WDT_TIMEOUT * 1000,                 // длительность тайм-аута в мс
      .idle_core_mask = (1 << portNUM_PROCESSORS) - 1,  // битовая маска для всех ядер
      .trigger_panic = true                             // включить перезагрузку ESP32
   };
   
   // Инициализируем таймер контроля задач (TWDT)
   // (эта функция настраивает и инициализирует TWDT - подписывает незанятые задачи, 
   // если она настроена для этого. Для других задач пользователи могут подписаться
   // с помощью esp_task_wdt_add() или esp_task_wdt_add_user(). Эта функция не 
   // запустит таймер, если ни одна задача еще не была зарегистрирована.
   // Примечание: esp_task_wdt_init() следует вызывать только после запуска планировщика. 
   // Более того, она не должна вызываться несколькими задачами одновременно.
   // Входной параметр конфигурационная структура, на возврате ESP_OK - инициализация 
   // прошла успешно, ESP_ERR_INVALID_STATE - уже инициализировано, другое - 
   // не удалось инициализировать TWDT)
   ESP32_ERROR = esp_task_wdt_init(&wdt_config);
   // Выводим текст ошибки (причину предыдущей перезагрузки) по её коду
   Serial.println("Причина предыдущей перезагрузки: " + String(esp_err_to_name(ESP32_ERROR)));
   
   // Подписываем текущую задачу под наблюдение TWDT
   // (эта функция подписывает задачу на TWDT. Каждая подписанная задача должна периодически
   // вызывать esp_task_wdt_reset(), чтобы предотвратить истечение срока ожидания TWDT. 
   // Невыполнение этого требования приведет к таймауту TWDT.
   // Параметр task_handle - дескриптор задачи. Устанавливается в  NULL, чтобы подписать 
   // текущую запущенную задачу на TWDT. Возврат: ESP_OK - успешно зарегистрирована 
   // задача в TWDT, другое - не удалось выполнить подписку на задачу)
   esp_task_wdt_add(NULL);  
}

// ****************************************************************************
// *                  Циклически отработать заданную задачу                   *
// ****************************************************************************
void loop() 
{
   // Запускаем задачу каждую секунду
   if (millis() - last >= 1000) 
   { 
      last = millis();
      Serial.print(i);
      Serial.print("s : ");
      i++;
      // Выполняем сброс сторожевого таймера каждые 10 секунд первой минуты
      // (после 60 секунд прекращаем сброс окончательно и, таким образом, инициируем 
      // перезагрузку контроллера по истечении тайм-аута - на 75 секунде)
      if (i % 20 <= 10 && i<60) 
      { 
         Serial.println(" Resetting WDT...");
         // Сбрасываем таймер контроля задач (TWDT) от имени текущей задачи
         // (каждая подписанная задача должна периодически вызывать эту функцию, 
         // чтобы предотвратить истечение времени ожидания TWDT. Если одной или 
         // нескольким подписанным задачам не удастся сбросить TWDT от своего имени, 
         // произойдет тайм-аут TWDT. Возврат: ESP_OK - успешно сброшено TWDT от 
         // имени текущей задачи, другое - не удалось выполнить сброс)
         esp_task_wdt_reset();
         // Делаем задержку в, как минимум, 1 мсек
         delay(1);  
         // Не инициируем сброса сторожевого таймера следующие 10 сек
         if (i % 20 == 10) 
         { 
            Serial.println("Stopping WDT reset.");
         }
      }
   }
}

// ************************************************** ex5-1-33_Watchdog.ino ***
