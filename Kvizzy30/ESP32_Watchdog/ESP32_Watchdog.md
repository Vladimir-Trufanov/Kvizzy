## [Обнаружение блокировки ESP32 с помощью внутреннего сторожевого таймера](https://github.com/TronixLab/ESP32_Watchdog?tab=readme-ov-file)

### I. Введение

Если ваша программа по какой-либо причине зависает, самый быстрый способ восстановления - перезагрузить компьютер. Одним из наиболее распространенных примеров был сбой операционной системы Windows (фатальная ошибка) и отображение синего экрана смерти (BSoD), после чего компьютер перезагружался, чтобы избежать дальнейшего повреждения. 

В отличие от настольных компьютеров, встроенные устройства должны быть автономными. Что делать, если вы не можете перезагрузить компьютер физически? Если программа зависает, не всегда возможно дождаться, пока кто-нибудь eё перезагрузит. Некоторые встроенные устройства, такие как космические зонды, просто недоступны для людей, и ручной сброс невозможен; они могут стать необратимо отключенными, если не смогут автономно восстанавливаться после сбоев. 

В таких ситуациях, Watchdog - это почти единственный способ спасти положение в подобных случаях. 

### II. Что такое сторожевой таймер?

Сторожевой таймер (WDT) - это аппаратный таймер, который может использоваться для автоматического обнаружения программных аномалий и автоматической генерации сброса системы, если основная программа пренебрегает его периодическим обслуживанием. 

Он часто используется для автоматического сброса встроенного устройства, зависшего из-за программного или аппаратного сбоя. 

> ***Сторожевой таймер основан на счетчике, который ведет обратный отсчет от некоторого начального значения до нуля. Встроенное программное обеспечение выбирает начальное значение счетчика и периодически перезапускает его. Если счетчик когда-либо достигает нуля до того, как программное обеспечение перезапустит его, предполагается, что программное обеспечение неисправно, и устанавливается сигнал сброса процессора.***

Процесс перезапуска счетчика сторожевого таймера иногда называют ***“пинать собаку”***. Подходящей визуальной метафорой является изображение человека, на которого нападает злобная собака. Если он продолжает пинать собаку, она никогда не сможет его укусить. Но он должен продолжать пинать собаку через равные промежутки времени, чтобы избежать укуса. 

Аналогично, программное обеспечение должно регулярно перезапускать сторожевой таймер, иначе возникает риск перезапуска. Другой термин для обозначения “пинка” - это ***"подача сторожевого таймера"***. На сторожевой таймер непрерывно подается начальное значение, так что значение таймера никогда не может достичь нуля.

![Рис.1 Типичная настройка сторожевого таймера](A-typical-Watchdog-setup.jpg)

На [рис.1](#) показано типичное расположение сторожевого таймера как внешнего блока по отношению к процессору. Однако он также может быть встроен в тот же чип, что и центральный процессор. Это делается во многих микроконтроллерах. В любом случае выходной сигнал сторожевого таймера напрямую связан с сигналом сброса процессора.

#### [Учебный пример сторожевого таймера в ESP32 board 5.1.33  (на контроллере AI-Thinker ESP32-CAM)](ex5-1-33_Watchdog/ex5-1-33_Watchdog.ino)

#### [Скетч "Базовый сторожевой таймер"](ex5-1-33_BasicWDT/ex5-1-33_BasicWDT.ino)

#### III. Каковы потенциальные причины события зависания?

Выход из строя микроконтроллера - MCU, как неисправность железа, так и неучтеные ситуации в программном коде могут привести к полной остановке работы. Это может доставить неудобства пользователям или создать угрозу функциональной безопасности в критически важных приложениях. 

Механизм безопасности чрезвычайно важен. Надежная встраиваемая система требует совместных усилий разработчика оборудования и программиста встроенного программного обеспечения. Существуют аппаратные и программные факторы, из-за которых MCU может отказать:

- электрический шум может вызвать сбой питания и повредить часть программного обеспечения;
- нестабильный источник питания;
- переполнение стека памяти;
- отсутствие ответа на запрос у аппаратного компонента;
- обратная ЭДС, электромагнитные помехи, электростатический разряд, космические лучи и т.д.;
- состояние мертвой блокировки;
- множественные прерывания основного цикла.

В ---- качестве одного из примеров, продемонстрированных в листинге 2, взаимоблокировка - это явление, когда две задачи находятся в заблокированном состоянии, ожидая ресурсов, удерживаемых одной и другой одновременно. При использовании операционной системы реального времени (FreeRTOS) такой тупиковой ситуации можно избежать только путем тщательного программирования приложений реального времени. В отличие от протокола назначения приоритетов, FreeRTOS не имеет решения проблемы взаимоблокировки. Ее можно решить только при проектировании встроенных систем реального времени. Мы должны проектировать задачи таким образом, чтобы не возникало взаимоблокировки.

Листинг 2 Взаимоблокировка




### Библиография

#### [Использование семафоров и мьютексов в FreeRTOS на Arduino Uno](https://microkontroller.ru/arduino-projects/ispolzovanie-semaforov-i-myuteksov-v-freertos-na-arduino-uno/)

#### [Debugging Arduino Errors with the ESP32 Exception Decoder - Отладка ошибок Arduino с помощью декодера исключений ESP32 ](https://www.donskytech.com/esp32-exception-decoder/)

#### Что такое ошибка Guru Meditation: Core 1 panic'ed…

Ошибка Guru Meditation, исходящая от вашего ESP32, является общей ошибкой, причины ее разнообразны и могут зависеть от конкретной схемы / программы. Обычно он показывает вам общую причину ошибки, некоторые дампы регистров и объекты обратной трассировки.

```
Guru Meditation Error: Core 1 panic'ed (LoadProhibited). Exception was unhandled.
Core 1 register dump:
PC : 0x400014e8 PS : 0x00060830 A0 : 0x800d133c A1 : 0x3ffb96d0
A2 : 0xa341aa26 A3 : 0xa341aa24 A4 : 0x000000ff A5 : 0x0000ff00
A6 : 0x00ff0000 A7 : 0xff000000 A8 : 0x00000000 A9 : 0x00000001
A10 : 0x00000001 A11 : 0x00060823 A12 : 0x00060820 A13 : 0x00000020
A14 : 0x00000000 A15 : 0x00000000 SAR : 0x0000000a EXCCAUSE: 0x0000001c
EXCVADDR: 0xa341aa24 LBEG : 0x4000c2e0 LEND : 0x4000c2f6 LCOUNT : 0xffffffff

ELF file SHA256: 0000000000000000

Backtrace: 0x400014e8:0x3ffb96d0 0x400d1339:0x3ffb96e0 0x400d136d:0x3ffb9700 0x400d0509:0x3ffb9720 0x40089792:0x3ffb9750
```

Глядя на журналы терминала, можете ли вы догадаться, в чём именно заключается ошибка? Думаю, если бы вы были героем из вселенной Marvel, то смогли бы сделать эту ошибку понятной для человека. Процесс преобразования этих значений в понятный человеку язык называется «декодированием», и мы будем использовать инструмент под названием [EspExceptionDecoder](https://github.com/me-no-dev/EspExceptionDecoder) в Arduino.

> Прежде чем мы продолжим, позвольте мне напомнить вам, что на данный момент (апрель 2023 г.) поддержка инструментов и плагинов в Arduino IDE 2 по-прежнему невозможна. Декодер EspException — это инструмент, написанный на Java, и плагин, который мы можем использовать для декодирования исключения. Поскольку плагины по-прежнему не поддерживаются в Arduino IDE 2, вы можете следовать этой статье, скачав старую (устаревшую) версию Arduino IDE 1.8.19 здесь.
 
#### Имитация ошибки ESP32

Давайте создадим очень простую программу Arduino, которая будет выдавать исключение во время выполнения.

```
#include<Arduino.h>

bool throwError = true;
int dynamicValue;

void setup()
{
  Serial.begin(115200);
}

void loop()
{
  delay(5000);
  if (throwError)
    dynamicValue = 0;
  else
    dynamicValue = 1;

  float error = 1 / dynamicValue;
  Serial.println(error);
  
}
```

В функции loop() Здесь мы моделируем некоторую логику, но в итоге мы делим 1 на ноль, что невозможно и приведёт к исключению во время выполнения.

К счастью, у нас есть инструмент, который может помочь нам проанализировать проблему, и я покажу вам, как это сделать в Arduino IDE.

#### Как установить декодер исключений ESPException в Arduino IDE?


### Библиография

#### [Watchdogs Esp32 - документация Espressif 5.3.1](https://docs.espressif.com/projects/esp-idf/en/v5.3.1/esp32/api-reference/system/wdts.html) 

#### [Введение в сторожевые таймеры (https://www.embedded.com/introduction-to-watchdog-timers/)](https://www.embedded.com/introduction-to-watchdog-timers/)




###### [в начало](#kvizzy)

0

1

2

3

4

5

6

7

8

9

0

1

2

3

4

5




