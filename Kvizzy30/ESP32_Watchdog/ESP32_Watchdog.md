## [Обнаружение блокировки ESP32 с помощью внутреннего сторожевого таймера](https://github.com/TronixLab/ESP32_Watchdog?tab=readme-ov-file)

### I. Введение

Если ваша программа по какой-либо причине зависает, самый быстрый способ восстановления - перезагрузить компьютер. Одним из наиболее распространенных примеров был сбой операционной системы Windows (фатальная ошибка) и отображение синего экрана смерти (BSoD), после чего компьютер перезагружался, чтобы избежать дальнейшего повреждения. 

В отличие от настольных компьютеров, встроенные устройства должны быть автономными. Что делать, если вы не можете перезагрузить компьютер физически? Если программа зависает, не всегда возможно дождаться, пока кто-нибудь eё перезагрузит. Некоторые встроенные устройства, такие как космические зонды, просто недоступны для людей, и ручной сброс невозможен; они могут стать необратимо отключенными, если не смогут автономно восстанавливаться после сбоев. 

В таких ситуациях, Watchdog - это почти единственный способ спасти положение в подобных случаях. 

### II. Что такое сторожевой таймер?

Сторожевой таймер (WDT) - это аппаратный таймер, который может использоваться для автоматического обнаружения программных аномалий и автоматической генерации сброса системы, если основная программа пренебрегает его периодическим обслуживанием. 

Он часто используется для автоматического сброса встроенного устройства, зависшего из-за программного или аппаратного сбоя. 

> ***Сторожевой таймер основан на счетчике, который ведет обратный отсчет от некоторого начального значения до нуля. Встроенное программное обеспечение выбирает начальное значение счетчика и периодически перезапускает его. Если счетчик когда-либо достигает нуля до того, как программное обеспечение перезапустит его, предполагается, что программное обеспечение неисправно, и устанавливается сигнал сброса процессора.***

Процесс перезапуска счетчика сторожевого таймера иногда называют ***“пинать собаку”***. Подходящей визуальной метафорой является изображение человека, на которого нападает злобная собака. Если он продолжает пинать собаку, она никогда не сможет его укусить. Но он должен продолжать пинать собаку через равные промежутки времени, чтобы избежать укуса. 

Аналогично, программное обеспечение должно регулярно перезапускать сторожевой таймер, иначе возникает риск перезапуска. Другой термин для обозначения “пинка” - это ***"подача сторожевого таймера"***. На сторожевой таймер непрерывно подается начальное значение, так что значение таймера никогда не может достичь нуля.

![Рис.1 Типичная настройка сторожевого таймера](A-typical-Watchdog-setup.jpg)

На [рис.1](#) показано типичное расположение сторожевого таймера как внешнего блока по отношению к процессору. Однако он также может быть встроен в тот же чип, что и центральный процессор. Это делается во многих микроконтроллерах. В любом случае выходной сигнал сторожевого таймера напрямую связан с сигналом сброса процессора.

#### [Учебный пример сторожевого таймера в ESP32 board 5.1.33  (на контроллере AI-Thinker ESP32-CAM)](ex5-1-33_Watchdog/ex5-1-33_Watchdog.ino)

#### [Скетч "Базовый сторожевой таймер"](ex5-1-33_BasicWDT/ex5-1-33_BasicWDT.ino)

#### III. Каковы потенциальные причины события зависания?

Выход из строя микроконтроллера - MCU, как неисправность железа, так и неучтеные ситуации в программном коде могут привести к полной остановке работы. Это может доставить неудобства пользователям или создать угрозу функциональной безопасности в критически важных приложениях. 

Механизм безопасности чрезвычайно важен. Надежная встраиваемая система требует совместных усилий разработчика оборудования и программиста встроенного программного обеспечения. Существуют аппаратные и программные факторы, из-за которых MCU может отказать:

- электрический шум может вызвать сбой питания и повредить часть программного обеспечения;
- нестабильный источник питания;
- переполнение стека памяти;
- отсутствие ответа на запрос у аппаратного компонента;
- обратная ЭДС, электромагнитные помехи, электростатический разряд, космические лучи и т.д.;
- состояние мертвой блокировки;
- множественные прерывания основного цикла.

В ---- качестве одного из примеров, продемонстрированных в листинге 2, взаимоблокировка - это явление, когда две задачи находятся в заблокированном состоянии, ожидая ресурсов, удерживаемых одной и другой одновременно. При использовании операционной системы реального времени (FreeRTOS) такой тупиковой ситуации можно избежать только путем тщательного программирования приложений реального времени. В отличие от протокола назначения приоритетов, FreeRTOS не имеет решения проблемы взаимоблокировки. Ее можно решить только при проектировании встроенных систем реального времени. Мы должны проектировать задачи таким образом, чтобы не возникало взаимоблокировки.

Листинг 2 Взаимоблокировка




### Библиография

#### [Использование семафоров и мьютексов в FreeRTOS на Arduino Uno](https://microkontroller.ru/arduino-projects/ispolzovanie-semaforov-i-myuteksov-v-freertos-na-arduino-uno/)

#### [Watchdogs Esp32 - документация Espressif 5.3.1](https://docs.espressif.com/projects/esp-idf/en/v5.3.1/esp32/api-reference/system/wdts.html) 

#### [Введение в сторожевые таймеры (https://www.embedded.com/introduction-to-watchdog-timers/)](https://www.embedded.com/introduction-to-watchdog-timers/)




###### [в начало](#kvizzy)

0

1

2

3

4

5

6

7

8

9

0

1

2

3

4

5




