## [Kvizzy30 - Стремящееся к умному хозяйство](#) 

### Kvizzy30 - управление встроенными светодиодами Esp32-CAM, контрольным и вспышкой, через сайт (модель нижнего уровня, стремящегося к умному, хозяйства)

---

### [Тезисы прoекта](#%D1%82%D0%B5%D0%B7%D0%B8%D1%81%D1%8B-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B0)

### [Слoварь](#%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C)

### [ESP32-CAM - справoчник по распиновке](#esp32-cam---%D1%81%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA-%D0%BF%D0%BE-%D1%80%D0%B0%D1%81%D0%BF%D0%B8%D0%BD%D0%BE%D0%B2%D0%BA%D0%B5)

### [ArduinоJSON](#arduinojson)

### [XML - генерация файла, синтаксический анализ](#xml---%D0%B3%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D1%84%D0%B0%D0%B9%D0%BB%D0%B0-%D0%B8-%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7)

---

### Тезисы проекта

1.  Контроллер ESP32-CAM может обрабатывать до 32 прерываний на каждое ядро.

2. Наибольший приоритет задачи - 25. Основной цикл ***Loop*** имеет приоритет = 1. Прерываниям установлены приоритеты, равные 0 (само собой, событие происходит и запускается обработка прерывания, независимо от приоритета задач).

3. Работают контрольный светодиод и вспышка в разных режимах.
 
4. Вспышка зажигается по команде со стороны сайта и горит заданное время в миллисекундах.

5. Режим работы контрольного светодиода определяется следующими параметрами: 
- длительность цикла "горит - не горит";
- процент времени свечения светодиода в цикле.

Режим работы включается и выключается по команде со стороны сайта.

6. Задачи:
- ***vLoop***, основной цикл, приоритет 1. ;
- ***vState***, выборка из очереди и сообщение от контроллера о состоянии его устройств и показаниях датчиков  (с интервалом 386 мсек) на страницу ***State***. Приоритет 9.
- ***vPrint***, выборка из очереди и вывод сообщений в последовательный порт  (с интервалом 486 мсек) . Приоритет 9.
- ***vLead***, регулярный (с интервалом 298 мсек) запрос контроллера на изменение состояний его устройств к странице ***Lead***. Приоритет 8.

7. Прерывания:

- ***irqToggleLedWork***, смена состояния (CHANGE) контрольного светодиода на 33 контакте. При изменении состояния светодиода в очередь ***queState*** отправляется json-строка состояния светодиода;

- ***irqLightLedFlash***, вспышка - изменение состояния 4 контакта с LOW на HIGH и обратно (CHANGE). Отправка json-строки состояния светодиода в очередь***queState***;

8. Очереди сообщений:

- ***queState***, очередь состояний устройств и показаний датчиков для отправки на страницу State;

- ***quePrint***, очередь сообщений в последовательный порт;

9. Старт приложения. 

- при старте приложения вспышка переводится в выключенное состояние и сообщение об этом передается в очередь ***queState***;

- контрольный светодиод переводится в режим с длительностью цикла "горит - не горит" равным 2014 секунд и процентом времени свечения светодиода в цикле равным 50. Cообщение об этом передается в очередь ***queState***;

```
###1###
send Led33: {"tidctrl":1,"nicctrl":"myjoy","led33":[{"tiddev":1,"nicdev":"inLed","status":"inLOW"}]}
shttp: https://doortry.ru/State/?Com={"tidctrl":1,"nicctrl":"myjoy","led33":[{"tiddev":1,"nicdev":"inLed","status":"inLOW"}]}***
getCore0: {"Core0":[{"minstack":34}]}

###0###
getCore1: {"core1":[{"iddev":1,"minstack":34}]}
send Led33: {"tidctrl":1,"nicctrl":"myjoy","led33":[{"tiddev":1,"nicdev":"inLed","status":"inHIGH"}]}
shttp: https://doortry.ru/State/?Com={"tidctrl":1,"nicctrl":"myjoy","led33":[{"tiddev":1,"nicdev":"inLed","status":"inHIGH"}]}***
getCore0: {"Core0":[{"minstack":34}]}

###1###
send Led33: {"tidctrl":1,"nicctrl":"myjoy","led33":[{"tiddev":1,"nicdev":"inLed","status":"inLOW"}]}
shttp: https://doortry.ru/State/?Com={"tidctrl":1,"nicctrl":"myjoy","led33":[{"tiddev":1,"nicdev":"inLed","status":"inLOW"}]}***
getCore1: {"core1":[{"iddev":1,"minstack":34}]}

```

### Словарь


 
 
 - ***Деятельность*** - выделенная часть основного цикла приложения, выполняющая  отдельную задачу.

###### [к содержанию](#%D1%82%D0%B5%D0%B7%D0%B8%D1%81%D1%8B-%D0%BF%D1%80o%D0%B5%D0%BA%D1%82%D0%B0)

### [ESP32-CAM - справочник по распиновке](https://lastminuteengineers.com/esp32-cam-pinout-reference/)

![](ESP32-CAM-Pinout.webp)

Контакты ADC2 используются драйвером Wi-Fi внутри устройства, они не могут использоваться при включенном Wi-Fi.

![Контакты ADC2 для WiFi](ESP32-CAM-ADC-Pins.webp)

Плата имеет 10 каналов (все выводы GPIO) ШИМ-выводов, управляемых ШИМ-контроллером. ШИМ-выход может использоваться для управления цифровыми двигателями и светодиодами.

![Каналы ШИМ-выводов](ESP32-CAM-PWM-Pins.webp)

ШИМ-контроллер состоит из ШИМ-таймеров, ШИМ-оператора и специального подмодуля захвата. Каждый таймер обеспечивает синхронизацию в синхронной или независимой форме, и каждый оператор PWM генерирует форму сигнала для одного канала PWM. Специальный вспомогательный модуль захвата может точно фиксировать события с внешней синхронизацией.

>***Есть два вывода питания: 5V и 3V3. Питание ESP32-CAM может осуществляться через выводы 3,3 В или 5 В. Поскольку многие пользователи сообщают о проблемах при подаче питания на устройство напряжением 3,3 В, рекомендуется, чтобы питание ESP32-CAM всегда подавалось через вывод 5 В.***
> 
> ***Вывод VCC обычно выдает 3,3 В от встроенного регулятора напряжения.***

###### [к содержанию](#%D1%82%D0%B5%D0%B7%D0%B8%D1%81%D1%8B-%D0%BF%D1%80o%D0%B5%D0%BA%D1%82%D0%B0)

### ArduinoJSON

###### [к содержанию](#%D1%82%D0%B5%D0%B7%D0%B8%D1%81%D1%8B-%D0%BF%D1%80o%D0%B5%D0%BA%D1%82%D0%B0)

### XML - генерация файла и синтаксический анализ

#### [PHP генерация XML-файла - SimpleXML, DOM, метод чтения / записи](https://way2tutorial.com/xml/php-generate-xml.php)

#### [ESP32 Arduino: синтаксический анализ XML](https://techtutorialsx.com/2019/11/20/esp32-arduino-parsing-xml/)

#### [How to parser XML with TinyXML2 C++](https://terminalroot.com/how-to-parser-xml-with-tinyxml2-cpp/)

Синтаксический анализ XML с помощью ESP32, используя ядро Arduino, как вариант, выполняется с помощью [tinyxml2: https://github.com/leethomason/tinyxml2](https://github.com/leethomason/tinyxml2) - библиотеки синтаксического анализа C++. 

Страница документации  к библиотеке [размещена здесь: https://leethomason.github.io/tinyxml2/index.html](https://leethomason.github.io/tinyxml2/index.html).

Для подключения библиотеки следует сделать следующее: в папке libraries создать новую папку с именем ***tinyxml2***. После этого перейти на страницу библиотеки GitHub и загрузить файлы ***tinyxml2.cpp*** и ***tinyxml2.h*** в только что созданную папку tinyxml2.

Пример работы с библиотекой ***tinyxml2***:

```
#include <tinyxml2.h>
using namespace tinyxml2;
char * testDocument = "<root><element>7</element></root>";

void setup() 
{
   Serial.begin(115200);
   XMLDocument xmlDocument;
   if(xmlDocument.Parse(testDocument)!= XML_SUCCESS)
   {
      Serial.println("Error parsing");
      return; 
   };

   XMLNode * root = xmlDocument.FirstChild();
   XMLElement * element = root->FirstChildElement("element");

   int val;
   element->QueryIntText(&val);
  
   Serial.println(val);
}

void loop() {}
```

### Библиография

###### [к содержанию](#%D1%82%D0%B5%D0%B7%D0%B8%D1%81%D1%8B-%D0%BF%D1%80o%D0%B5%D0%BA%D1%82%D0%B0)
