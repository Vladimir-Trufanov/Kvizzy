/** Arduino-Esp32-CAM                               *** LwIPSNTPexample.ino ***
 * 
 *       Использовать модуль LwIP SNTP для получения времени и даты с интернет-
 *  серверов с помощью SNTP - «простого сетевого протокола времени». Библиотека 
 *    LwIP SNTP (#include "esp_sntp.h") обеспечивает получение текущего времени 
 *                                 и синхронизацию таймера ESP32 с сервером NTP
 *         для плат ESP32 в версии библиотеки от Espressif Systems версии 3.0.6
 *                                        (на контроллере AI-Thinker ESP32-CAM)
 * 
 * v1.2, 13.11.2024                                   Автор:      Труфанов В.Е.
 * Copyright © 2024 tve                               Дата создания: 11.11.2024
**/

#include <Arduino.h>
#include "nvs_flash.h"
#include "nvs.h"

// Готовим подключение к WiFi через имя и пароль точки доступа
#include "WiFi.h"
const char* ssid     = "OPPO A9 2020";
const char* password = "b277a4ee84e8";

// Подключаем библиотеку для связи с сервером SNTP:

// - функция gettimeofday используется для получения текущей метки времени;
// - функция settimeofday используется для установки текущего времени при 
//   получении ответа от сервера NTP;
// - функция sntp_get_sync_status() используется для получения информации о 
//   состоянии синхронизации времени. Если время синхронизировано, то возвращается 
//   ответ SNTP_SYNC_RETURN_COMPLETED. Если состояние сброшено, то возвращается 
//   SNTP_SYC_STATUS_RESET. Кроме того, если происходит плавная синхронизация 
//   времени, то возвращается ответ SNTP_SYNC_STATUS_IN_PROGRESS;
// - функция sntp_set_sync_status() используется для установки статуса синхронизации 
//   времени. Она принимает один параметр — «sync_status», который является 
//   статусом синхронизации времени;
// - функция sntp_get_sync_mode() используется для получения режима синхронизации 
//   времени. Эта функция возвращает значение SNTP_SYNC_MODE_IMMEDIATE, если 
//   синхронизация настроена на немедленное обновление времени. В противном случае 
//   она возвращает SNTP_SYNC_MODE_SMOOTH - так как настроено плавное обновление времени;
// - функция sntp_set_sync_mode() используется для установки режима синхронизации 
//   времени. Она принимает один параметр «sync_mode», который является режимом 
//   синхронизации. Режим может быть SNTP_SYNC_MODE_IMMEDIATE или SNTP_SYNC_MODE_SMOOTH. 
//   Если выбран режим SNTP_SYNC_MODE_IMMEDIATE, системное время обновляется 
//   сразу после получения данных с сервера SNTP. Если выбран режим SNTP_SYNC_MODE_SMOOTH, 
//   устанавливается плавное обновление времени. В этом случае для уведомления 
//   о времени используется функция adjtime;
// - функция sntp_set_time_sync_notification_cb() используется для установки 
//   функции обратного вызова по уведомлению о синхронизации времени. Она 
//   принимает один параметр — функцию обратного вызова.

//   ESP32 использует два аппаратных таймера для отслеживания системного 
// времени: 
// - таймер RTC: позволяет отслеживать время в различных режимах сна, а также 
//   сохранять время при любых сбросах (за исключением сброса при включении питания, 
//   который сбрасывает таймер RTC). Отклонение частоты зависит от источников 
//   тактового сигнала таймера RTC и влияет на точность только в режимах сна, 
//   в которых время будет измеряться с точностью до 6,6667 мкс;
// - таймер с высоким разрешением: этот таймер недоступен в спящих режимах и не 
//   сохраняется после перезагрузки, но обладает большей точностью. Таймер 
//   использует источник тактовых импульсов APB_CLK (обычно 80 МГц), отклонение 
//   частоты которого составляет менее ±10 частей на миллион. Время измеряется с 
//   точностью до 1 мкс.
// Системное время можно отслеживать с помощью одного или обоих аппаратных 
// таймеров в зависимости от целей приложения и требований к точности системного 
// времени (при умалчиваемом режиме подключены оба таймера, это гарантирует, что 
// после синхронизации с сервером SNTP время будет отсчитываться с помощью обоих 
// таймеров. Когда плата ESP32 будет находиться в режиме глубокого сна, для отслеживания 
// времени будет использоваться встроенный таймер RTC, а таймер FRC1 с высоким 
// разрешением обеспечит точность времени до микросекунд, пока плата будет 
// находиться в активном режиме. 
#include "esp_sntp.h"

// Создаем переменную локального времени (секунды с начала эпохи)
time_t now;
// Создаем структуру времени timeinfo в которую будем вкладывать
// выбранное и преобразованное время в секундах с начала эпохи
struct tm timeinfo;

// Объявляем переменную, которая содержит количество перезагрузок ESP32. 
// RTC_DATA_ATTR указывает на хранение этой статической переменной типа int 
// в памяти RTC. Это гарантирует, что значение boot_count сохранится, когда плата 
// ESP32 перейдёт в режим глубокого сна, а затем проснётся.
RTC_DATA_ATTR static int boot_count = 0; 

// ****************************************************************************
// *      Подключить ESP32 к указанной сети Wi-Fi (непрерывно проверять       *
// *  состояние подключения до тех пор, пока оно не будет успешно установлено *
// ****************************************************************************
void initWiFi() 
{
   WiFi.begin(ssid, password);
   while (WiFi.status() != WL_CONNECTED) 
   {
      delay(500);
      Serial.print(".");
   }
   Serial.println(" ");
}
// ****************************************************************************
// * Настроить интервал синхронизации, имя сервера, режим работы и часовой пояс
// ****************************************************************************
void notify(struct timeval* t) 
{
   Serial.println("Синхронизировано!");
}
void initSNTP() 
{ 
   // Определяем, как часто синхронизировать внутренние часы ESP32 с сервером 
   // SNTP. Интервал указывается в микросекундах. Интервал в 60*60*1000UL 
   // микросекунд означает синхронизацию каждый час. Разумные интервалы запросов 
   // обычно составляют от одного-двух раз в день до 5 раз в час. 
   sntp_set_sync_interval(1 * 60 * 60 * 1000UL);  
   // sntp_set_sync_interval(1 * 10 * 60 * 1000UL);  // 10 минут
   // Указываем функцию уведомления (callback), которая вызывается при каждой 
   // синхронизации. В данном коде для этой цели определяем функцию notify(), 
   // которая просто выводит «synchronized». 
   sntp_set_time_sync_notification_cb(notify);
   // Устанавливаем режим работы: ESP_SNTP_OPMODE_POLL — просто опрашивать
   // сервер SNTP (есть также ESP_SNTP_OPMODE_LISTENONLY)
   esp_sntp_setoperatingmode(ESP_SNTP_OPMODE_POLL);
   // Указываем имя/адрес сервера. При желании можно указать несколько серверов.
   // Например:
   //           esp_sntp_setservername(0, «pool.ntp.org»);
   //           esp_sntp_setservername(1, «de.pool.ntp.org»);
   //           esp_sntp_setservername(2, «time.nist.gov»);
   esp_sntp_setservername(0, "pool.ntp.org");
   // Запускаем службу SNTP с указанными выше параметрами
   esp_sntp_init();
   // Устанавливаем часовой пояс, поскольку сервер SNTP 
   // возвращает время в формате UTC
   setTimezone();
}
// ****************************************************************************
// *                           Настроить часовой пояс                         *
// ****************************************************************************
void setTimezone() 
{ 
   // Здесь установливается стандартное время для региона - Европа/Москва
   // https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv
   setenv("TZ", "MSK-3", 1);
   tzset();
}
// ****************************************************************************
// *                            Ожидать синхронизацию                         *
// ****************************************************************************
void wait4SNTP() 
{
  while (sntp_get_sync_status() != SNTP_SYNC_STATUS_COMPLETED) 
   {
      delay(500);
      Serial.println("ожидание синхронизации ...");
   }
}
// ****************************************************************************
// *   Извлечь информацию о текущем времени и вывести ее в отформатированном  *
// *   виде с помощью struct tm структуры данных:                             *
// *                               https://cplusplus.com/reference/ctime/tm/  *
// ****************************************************************************
/*
 "%A, %B %d %Y %H:%M:%S" - это спецификаторы формата,  которые определяют,  как
 в struct tm timeinfo; будет отформатирован текст, а члены tm struct следующие:
  
  Тип элемента Значение                        Диапазон
  -----------------------------------------------------
  tm_sec  int  секунды после минуты            0-61*
  tm_min  int  минуты после часа               0-59
  tm_hour int  часы с полуночи                 0-23
  tm_mday int  день месяца                     1-31
  tm_mon  int  месяцы с января                 0-11
  tm_year int  годы с 1900
  tm_wday  —   количество дней с воскресенья   0-6
  tm_yday  —   количество дней с 1 января      0-365
  tm_isdst —   флаг перехода на летнее время 
  
  function strftime() - format time as string:
  https://cplusplus.com/reference/ctime/strftime/
*/
void printTime() 
{
   struct tm timeinfo;
   getLocalTime(&timeinfo);
   Serial.println(&timeinfo, "%A, %B %d %Y %H:%M:%S");

   printf("%d-%d-%d %d:%d:%d\n", 
   timeinfo.tm_year+1900, timeinfo.tm_mon+1, timeinfo.tm_mday,
   timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);
}

void ViewLocalTime()
{
   // Устанавливаем часовой пояс на восточное стандартное время 
   // и выводим местное время
   char strftime_buf[64];
   setenv("TZ", "EST5EDT,M3.2.0/2,M11.1.0", 1);
   tzset();
   localtime_r(&now, &timeinfo);
   strftime(strftime_buf, sizeof(strftime_buf), "%c", &timeinfo);
   printf("Текущие дата и время в Нью-Йорке: %s\n", strftime_buf);
   // Устанавливаем часовой пояс на Шанхайское стандартное время
   setenv("TZ", "CST-8", 1);
   tzset();
   localtime_r(&now, &timeinfo);
   strftime(strftime_buf, sizeof(strftime_buf), "%c", &timeinfo);
   printf("Текущие дата и время в Шанхае: %s\n", strftime_buf);
}

void setup() 
{
   Serial.begin(115200);
   initWiFi();
   // После каждой перезагрузки увеличиваем счётчик загрузок
   // и выводим в терминал.
   ++boot_count;
   printf("Счетчик перезапусков = %d\n", boot_count);
   // Выбираем время с начала эпохи
   time(&now);
   // Переносим время в структуру времени
   localtime_r(&now, &timeinfo);
   printf("Прошло с 'начала эпохи = 1900 года' %d\n", timeinfo.tm_year);
   // Если правильное время ещё не установлено, то настраиваем интервал синхронизации, 
   // имя сервера, режим работы, часовой пояс и получаем время с сервера SNTP 
   if (timeinfo.tm_year < (2023 - 1900)) 
   {
   ViewLocalTime();
      // Показываем начальные заграничное и местное время
      setTimezone();
      printTime();
      Serial.println("Время еще не установлено. Подключаемся к Wi-Fi и получаем время по протоколу SNTP");
      // Инициируем SNTP
      initSNTP();
      wait4SNTP();
      // Показываем установленные дату и время
      time(&now);
      ViewLocalTime();
   }
   // Показываем местные дату и время
   setTimezone();
   printTime();
   // Переводим систему в глубокий сон на 10 секунд
   const int deep_sleep_sec = 10;
   printf("Переход в глубокий сон на %d секунд!\n", deep_sleep_sec);
   esp_deep_sleep(1000000LL * deep_sleep_sec);
}

void loop() 
{
}

// **************************************************** LwIPSNTPexample.ino ***
