## [Как работать с очередями во FreeRTOS](#)

Очереди очень полезны для безопасной передачи сообщений от одной задачи к другой. Обмен сообщениями между задачами выполняется по правилу FIFO (первым сообщение пришло -  первым уйдет), то есть новые данные добавляются в конец очереди и извлекаются из начала.

У FreeRTOS очень богатый API очередей, который предлагает большое число возможностей. 

---

### [Введение - быстрое знакомство](#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5)

### [xQueueCreate - coздать новую очередь](#xqueuecreate---c%D0%BE%D0%B7%D0%B4%D0%B0%D1%82%D1%8C-%D0%BD%D0%BE%D0%B2%D1%83%D1%8E-%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C)

### [xQueueSend - пoместить элемент в очередь](#xqueuesend---%D0%BF%D0%BE%D0%BC%D0%B5%D1%81%D1%82%D0%B8%D1%82%D1%8C-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82-%D0%B2-%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C)

### [xQueueReceive - выбрать элемент из oчереди](#xqueuereceive---%D0%B2%D1%8B%D0%B1%D1%80%D0%B0%D1%82%D1%8C-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82-%D0%B8%D0%B7-%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D0%B8)

### [Управление очередями](https://www.freertos.org/Documentation/02-Kernel/04-API-references/06-Queues/00-QueueManagement)

---

### [Введение](https://techtutorialsx.com/2017/08/20/esp32-arduino-freertos-queues/)

Один очень важный аспект, о котором следует помнить, заключается в том, что данные, которые помещаются в очередь, копируются, а не просто сохраняется ссылка на них. Это означает, что если мы отправим в очередь целое число, его значение будет фактически скопировано, и если мы изменим исходное значение после этого, проблем возникнуть не должно.

Тем не менее, при вызове функций с очередями следует ссылаться на данные через указатели (это особенно полезно, если сообщения для обмена большие). 

Следует также учитывать, что при вставке в заполненную очередь или извлечении из пустой очереди могут выполняться блокирующие вызовы в течение заданного периода времени (этот период времени является параметром API).

В первом, ознакомительном, примере работа с очередью из 10 целых чисел показана только в основном цикле приложения loop, для того чтобы сосредоточиться на базовых вызовах API, которые нужно выполнять.

Для работы не требуется дополнительных библиотек. При подключении к IDE Arduino плат разработки для Esp32 операционная система FreeRTOS подключается автоматически вместе с библиотекой очередей - ***queue.h***.

Таким образом, код начинается с объявления глобальной переменной типа QueueHandle_t, который нужен для ссылки на очередь FreeRTOS.

```
QueueHandle_t queue;
```

В первую очередь, в функции настройки открывается последовательный порт  для вывода результатов приложения. Далее создаётся очередь с помощью вызова функции ***xQueueCreate***. Эта функция принимает в качестве первого аргумента максимальное количество элементов, которые очередь может содержать, а в качестве второго аргумента — размер (в байтах) каждого элемента. ***Обратите внимание, что каждый элемент очереди должен иметь одинаковый размер***.

В примере создается очередь, которая может содержать максимум 10 элементов (целых чисел), где размер каждого элемента указывается в байтах с помощью функции ***sizeof***.

При успешном выполнении функция xQueueCreate вернёт дескриптор очереди, который имеет тип ***QueueHandle_t***, как и переменная, которая объявлена глобально. В случае возникновения проблем с выделением очереди будет возвращён ***NULL***. Таким образом, после проверки возвращённого результата функцией можно предупредить пользователя о возникновении проблемы.

```
void setup() 
{
   Serial.begin(115200);
   queue = xQueueCreate(10, sizeof(int));
   if (queue == NULL)
   {
      Serial.println("Error creating the queue");
   }
}
```
В начале основного цикла приложения определяется, создана ли очередь. Если все в порядке и очередь организована, то с помощью функции ***xQueueSend*** добавляются элементы в конец очереди для последующего использования.

Эта функция получает в качестве первого параметра дескриптор объявленной очереди. В качестве второго параметра она получает указатель на элемент, который следует вставить (хотя передаётся указатель, но в очередь копируется элемент), а в качестве последнего аргумента - максимальное время ожидания задачи в случае, если очередь заполнена.

Для последнего аргумента значение указывается в тиках (квантах FreeRTOS). Передача значения ***portMAX_DELAY*** означает, что ожидание будет продолжаться бесконечно, если очередь заполнена. 

Поскольку очередь может содержать максимум 10 элементов, организуется простой цикл for и на каждой итерации вставляется текущее значение.

```
for (int i = 0; i<10; i++)
{
   xQueueSend(queue, &i, portMAX_DELAY);
}
```

Обратите внимание, что всегда ***передаётся указатель на одну и ту же переменную, но поскольку её фактическое значение будет скопировано***, то нет никаких проблем с изменением её на новое значение на каждой итерации.

Аналогичный цикл используется для извлечения элементов очереди. Для того, чтобы обработать элемент, следует просто вызвать функцию ***xQueueReceive***. Она получит в качестве первого параметра дескриптор очереди, в качестве второго параметра - указатель на буфер, в который будет скопирован полученный элемент, и, наконец, количество тиков для ожидания, если очередь пуста.

Как и прежде, в качестве первого аргумента передаётся глобальная переменная - дескриптор очереди, а в качестве последнего - значение ***portMAX_DELAY***. Что касается буфера, в который копируется элемент, то перед использованием элемента объявляется переменная целочисленного типа, в которой сохраняется полученный элемент.

Следует заметить, что ***при выборке элемента он будет удалён из очереди***. Если не требуется удалять элемент при извлечении, можно использовать функцию ***xQueuePeek***.

В цикле обработки элементов их значения выводятся в последовательный порт. 

```
int element;
for (int i = 0; i<10; i++)
{
   xQueueReceive(queue, &element, portMAX_DELAY);
   Serial.print(element);
   Serial.print("|");
}
```
В завершении цикла добавляется задержка между каждой итерацией основного цикла.

#### [Скетч "Пример работы с очередью"](QueueHandleOne/QueueHandleOne.ino)

###### [к содержанию](#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5---%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%BE%D0%B5-%D0%B7%D0%BD%D0%B0%D0%BA%D0%BE%D0%BC%D1%81%D1%82%D0%B2%D0%BE)

---

### [xQueueCreate - cоздать новую очередь](https://www.freertos.org/Documentation/02-Kernel/04-API-references/06-Queues/01-xQueueCreate)

Функция ***xQueueCreate*** создаёт новую очередь и возвращает дескриптор, с помощью которого можно ссылаться на эту очередь. 

```
 QueueHandle_t xQueueCreate(UBaseType_t uxQueueLength, UBaseType_t uxItemSize);
```
Перед первым использованием очередей следует просмотреть заголовочный файл ***FreeRTOSConfig.h***. Определение ***configSUPPORT_DYNAMIC_ALLOCATION*** должно быть установлено в 1 или не определено (в этом случае по умолчанию будет равно 1), чтобы эта функция RTOS API была доступна.

```
#define configSUPPORT_DYNAMIC_ALLOCATION             1
```

Для каждой очереди требуется оперативная память, которая используется для хранения состояния очереди и элементов, содержащихся в очереди (область хранения очереди). Если очередь создаётся с помощью ***xQueueCreate()***, тогда необходимая оперативная память автоматически выделяется из кучи FreeRTOS. 

Если очередь создаётся с помощью ***xQueueCreateStatic()***, то оперативная память предоставляется разработчиком приложения, что приводит к увеличению количества параметров, но позволяет выделить оперативную память статически во время компиляции. 

Параметры:

- ***uxQueueLength***, максимальное количество элементов, которое очередь может содержать одновременно;
- ***uxItemSize***, размер в байтах, необходимый для хранения каждого элемента в очереди. Элементы добавляются в очередь копированием, а не по ссылке, поэтому это количество байт, которые будут скопированы для каждого элемента в очереди. Каждый элемент в очереди должен иметь одинаковый размер.

Возврат:

если очередь создана успешно, то возвращается дескриптор созданной очереди. Если память, необходимая для создания очереди, не может быть выделена, то возвращается ***NULL***.

```
struct AMessage
{
   char ucMessageID;
   char ucData[20];
};

void vATask(void *pvParameters)
{
   QueueHandle_t xQueue1, xQueue2;
   // Создаём очередь, способную содержать до 10 чисел типа unsigned long
   xQueue1 = xQueueCreate(10, sizeof(unsigned long));
   if(xQueue1==NULL)
   {
      /* Очередь не была создана и не должна использоваться */
   }
   // Создаем очередь, способную содержать 10 структур, которые должны
   // быть помещены в очередь с помощью указателей, поскольку представляют
   // собой относительно большие данные
   xQueue2 = xQueueCreate(10, sizeof(struct AMessage));
   if( xQueue2 == NULL )
   {
      /* Очередь не была создана и не должна использоваться */
   }
   /* ... остальная часть кода задачи */
}

```

###### [к содержанию](#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5---%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%BE%D0%B5-%D0%B7%D0%BD%D0%B0%D0%BA%D0%BE%D0%BC%D1%81%D1%82%D0%B2%D0%BE)

---

### [xQueueSend - поместить элемент в очередь](https://www.freertos.org/Documentation/02-Kernel/04-API-references/06-Queues/03-xQueueSend)

Функция ***xQueueSend*** отправляет элемент в очередь. Хотя элемент, передаваемый в функцию, указывается как параметр по ссылке (через указатель) фактически в очередь укладывается копия элемента.

Эту функцию нельзя вызывать из подпрограммы обслуживания прерываний. Для этого используется функция ***xQueueSendFromISR()***.

Формат:

```
BaseType_t xQueueSend(QueueHandle_t xQueue,const void *pvItemToQueue,TickType_t xTicksToWait);
```

По сути это макрос, который вызывает ***xQueueGenericSend()***. Он включён для обратной совместимости с более ранними версиями FreeRTOS, в которых не было ***xQueueSendToFront()*** и ***xQueueSendToBack()***.

Параметры:

- ***xQueue***, дескриптор очереди, в которой должен быть размещен элемент;

- ***pvItemToQueue***, указатель на элемент, который необходимо поместить в очередь. Размер элементов, которые содержит очередь, должен быть определён при создании очереди, поэтому по указателю будет скопировано столько байт, каков указан размер элемента в хранилище очереди;

- ***xTicksToWait***, максимальное время, в течение которого задача должна блокироваться в ожидании освобождения места в очереди, если она уже заполнена.

Вызов функции будет повторен немедленно, если очередь заполнена, а значение параметра xTicksToWait равно 0.

Время определяется в тактовых периодах, поэтому для расчета реального времени блокировки в миллисекундах или в других единицах нужно использовать значение константа ***portTICK_PERIOD_MS***.

Если для ***INCLUDE_vTaskSuspend*** во FreeRTOSConfig.h установлено значение «1» (это по умолчанию), а время блокировки указано как p***ortMAX_DELAY***, то это приведет к блокировке задачи на неопределенный срок (без истечения времени ожидания).

Возврат:

- ***pdTRUE***, если сообщение было успешно отправлено,
- ***errQUEUE_FULL*** в противном случае.

Пример использования:
```
struct AMessage
{
   char ucMessageID;
   char ucData[20];
 } xMessage;
 
unsigned long ulVar = 10UL;

void vATask(void *pvParameters)
{
   QueueHandle_t xQueue1, xQueue2;
   struct AMessage *pxMessage;
   
   // Создаём очередь, способную содержать 10 длинных целых без знака
   xQueue1 = xQueueCreate(10, sizeof(unsigned long));
   // Создаём очередь, способную содержать 10 указателей на структуры
   // сообщений. Они должны передаваться по указателю, поскольку содержат
   // длинные строки
   xQueue2 = xQueueCreate(10, sizeof(struct AMessage *));
   
   /* ... */
   
   if(xQueue1 != 0)
   {
      // Посылаем беззнаковые целые. Ждем 10 секунд, пока освободится 
      // место, при необходимости освобождаем его
      if (xQueueSend(xQueue1, (void *) &ulVar, (TickType_t) 10) != pdPASS)
      {
         /* Не удалось отправить сообщение даже после 10 тиков */
      }
   }
   
   if (xQueue2 != 0)
   {
      // Отправляем указатель на структуру AMessage (не блокируем, если
      // очередь уже заполнена
      pxMessage = & xMessage;
      xQueueSend(xQueue2, ( void *) &pxMessage, (TickType_t) 0);
   }
   /* ... остальная часть кода задачи */
}
```
 
###### [к содержанию](#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5---%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%BE%D0%B5-%D0%B7%D0%BD%D0%B0%D0%BA%D0%BE%D0%BC%D1%81%D1%82%D0%B2%D0%BE)

---

### [xQueueReceive - выбрать элемент из очереди](https://www.freertos.org/Documentation/02-Kernel/04-API-references/06-Queues/09-xQueueReceive)

Функция ***xQueueReceive*** извлекает элемент из очереди. Элемент получается путём копирования, поэтому необходимо предоставить буфер подходящего размера. Количество байт, скопированных в буфер, должно соответствовать значению, которое было определено при создании очереди.

Эту функцию нельзя использовать в подпрограмме обслуживания прерываний, альтернативой должно служить ***xQueueReceiveFromISR***.

Формат:

```
BaseType_t xQueueReceive(QueueHandle_t xQueue,void *pvBuffer,TickType_t xTicksToWait);
```

***xQueueReceive*** - это макрос, который вызывает ***xQueueGenericReceive()***.

Параметры:

- ***xQueue*** - дескриптор очереди, из которой должен быть получен элемент;

- ***pvBuffer*** - указатель на буфер, в который будет скопирован полученный элемент;

- ***xTicksToWait*** - максимальное время, в течение которого задача должна блокироваться в ожидании поступления элемента, если очередь пуста на момент вызова. Если xTicksToWait установлен в 0, то при пустой очереди функция немедленно вернёт значение 0. 

Время ожидания определяется в тактовых периодах, поэтому для определения реального времени следует использовать в пересчете значение константы ***portTICK_PERIOD_MS***.

Если для ***INCLUDE_vTaskSuspend*** установлено значение '1' (а это по умолчанию), то время блокировки, указанное как ***portMAX_DELAY*** приведет к блокировке задачи на неопределенный срок (без истечения времени ожидания).

Возврат: ***pdTRUE***, если элемент был успешно получен из очереди, в противном случае ***pdFALSE***.

Пример использования:

```
// Определяем переменную-структуру AMessage
struct AMessage
{
   char ucMessageID;
   char ucData[20];
}  xMessage;

// Определяем очередь, которая будет использоваться для отправки 
// и получения сообщений в виде структуры типа AMessage
QueueHandle_t xStructQueue = NULL;

// Определяем очередь, которая будет использоваться для отправки
// и получения указателей на структуры
QueueHandle_t xPointerQueue = NULL;

void vCreateQueues(void) 
{
   xMessage.ucMessageID = 0xab;
   memset(&(xMessage.ucData), 0x12, 20);
   
   // Создаём очередь для отправки полных сообщений-структур. Ее также
   // можно создать и позже, но необходимо позаботиться о том, чтобы
   // очередь не использовалась до тех пор, пока она не будет создана
   xStructQueue  =  xQueueCreate(10, sizeof(xMessage));
   
   // Создаём очередь для отправки указателей на структуры AMessage
   xPointerQueue = xQueueCreate(10, sizeof(&xMessage));
   
   if ((xStructQueue == NULL) || (xPointerQueue == NULL))
   {
      // "Не удалось создать одну или несколько очередей из-за нехватки
      // доступной памяти в куче. Исправьте ошибку здесь. 
      // Очереди также могут быть созданы  статически
   }
}

// Задача, которая выполняет запись в очередь
void vATask(void *pvParameters)
{
   struct AMessage *pxPointerToxMessage;
   
   // Отправляем всю структуру в очередь, созданную для хранения 10 структур
   xQueueSend( 
      // Дескриптор очереди
      xStructQueue,
      // Адрес переменной xMessage  sizeof(struct AMessage), откуда
      // байты копируются в очередь
      (void *) &xMessage,
      // Время блокировки, равное 0, означающее, что не нужно блокировать 
      // задачу, если очередь уже заполнена. Следует проверять значение,
      // возвращаемое функцией xQueueSend(), чтобы узнать, было ли
      // сообщение успешно отправлено в очередь
      (TickType_t  0)
   );
                             
   // Сохраняем адрес переменной xMessage в переменной-указателе
   pxPointerToxMessage = &xMessage;
   
   // Отправляем адрес сообщения в очередь, созданную 
   // для хранения 10 указателей
   xQueueSend (xPointerQueue, (void *) &pxPointerToxMessage,  (TickType_t) 0);
                
   /* ... некоторая часть кода */
}

// Задача, которая выполняет чтение из очереди
void vADifferentTask(void *pvParameters)
{
   struct AMessage xRxedStructure, *pxRxedPointer;
   if (xStructQueue != NULL)
   {
      // Получаем сообщение из созданной очереди для хранения сложного
      // структурного сообщения. Блокировка на 10 тиков, если сообщение
      // недоступно немедленно. Значение считывается в структурную
      // переменную AMessage, поэтому после вызова xQueueReceive()  
      // xRxedStructure будет содержать копию сообщения
      
      if (xQueueReceive(xStructQueue, &(xRxedStructure), (TickType_t) 10) == pdPASS)
      {
         /* xRxedStructure теперь содержит копию xMessage. */
      }
   }
   
   if (xPointerQueue != NULL)
   {
      // Получаем сообщение из созданной очереди для хранения указателей.
      // Блокируем на 10 тиков, если сообщение недоступно - немедленно.
      // Значение считывается в переменную указателя, и полученное значение
      // является адресом сообщения. Переменная, после этого вызова
      // pxRxedPointer будет указывать на xMessage.
      
      if (xQueueReceive(xPointerQueue,  &(pxRxedPointer), (TickType_t) 10) == pdPASS)
      {
         /* *pxRxedPointer теперь указывает на xMessage. */
      }
   }
   /* ... остальная часть кода задачи */
}  
```

###### [к содержанию](#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5---%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%BE%D0%B5-%D0%B7%D0%BD%D0%B0%D0%BA%D0%BE%D0%BC%D1%81%D1%82%D0%B2%D0%BE)

---

### Библиография

#### [Queue Management](https://www.freertos.org/Documentation/02-Kernel/04-API-references/06-Queues/00-QueueManagement)

#### [FreeRTOS queues](https://www.freertos.org/Documentation/02-Kernel/02-Kernel-features/02-Queues-mutexes-and-semaphores/01-Queues)





---

### [ESP32 Arduino: FreeRTOS Queues](https://techtutorialsx.com/2017/08/20/esp32-arduino-freertos-queues/)




###### [к содержанию](#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5---%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%BE%D0%B5-%D0%B7%D0%BD%D0%B0%D0%BA%D0%BE%D0%BC%D1%81%D1%82%D0%B2%D0%BE)

0

1

2

3

4

5

6

7

8

9

0

1

2

3

4

5




