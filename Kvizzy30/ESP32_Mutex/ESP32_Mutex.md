## [ESP32_Mutex 5.3.1]() 

#### [Как писать параллельные многозадачные приложения для ESP32 с использованием FreeRTOS и Arduino](https://www.circuitstate.com/tutorials/how-to-write-parallel-multitasking-applications-for-esp32-using-freertos-arduino/)

Узнайте, как воспользоваться преимуществами многозадачности FreeRTOS для двухъядерной SoC ESP32, используя вашу любимую Arduino IDE. Воспользуйтесь нашими примерами, чтобы узнать о мьютексе, семафоре и коде критической секции.

ESP32 — это мощный и многофункциональный SoC от Espressif. Он, несомненно, является одним из наших любимых. Одна из причин, по которой он нам так нравится, заключается в том, что это двухъядерный SoC с высокой тактовой частотой и большим объёмом памяти. Два ядра означают, что внутри кристалла SoC находятся два отдельных процессора. Чтобы в полной мере воспользоваться этими потрясающими аппаратными функциями, обычного метода последовательного программирования недостаточно. Последовательное программирование или выполнение — это когда одна задача выполняется, а все остальные задачи ожидают завершения выполняемой задачи. Напротив, если вы думаете о своём персональном компьютере, то знаете, что можете выполнять несколько задач одновременно, как если бы каждая задача/приложение выполнялись параллельно и независимо друг от друга. Хотя последовательное программирование может это обеспечить, если выполняется достаточно быстро, есть реальные преимущества в использовании «истинного параллелизма» с несколькими ядрами. К счастью, мы можем писать настоящие параллельные приложения для ESP32 в среде Arduino благодаря отличной поддержке инженеров Espressif. Для этого вам не нужно ничего устанавливать. Это уже есть в среде Arduino, и вы сознательно или бессознательно использовали это, если когда-либо работали с ESP32. В этом руководстве мы научимся правильно писать параллельные задачи для ESP32 с помощью FreeRTOS и Arduino Development Framework (ADF).

Если вы новичок в работе с ESP32, у нас есть отличное руководство по началу работы, в котором мы используем плату DOIT ESP32 DevKit V1 для демонстрации.

### Последовательное или параллельное программирование

Это сложная тема в области компьютерных наук, и мы не будем рассматривать её полностью. Вместо этого мы ограничимся деталями, достаточными для понимания концепции и целей этого руководства. Мы будем использовать знакомые примеры и по возможности среду Arduino. Мы знаем, что в базовой программе Arduino есть как минимум две функции: setup() и loop(). Эти функции представляют собой две логические конструкции, которые помогают нам реализовать логику нашей прикладной программы. Функция setup() запускается только один раз после включения питания и инициализирует все необходимые нам контакты и интерфейсы. Функция loop() с другой стороны может содержать последовательность инструкций, которая будет перезапускаться после завершения итерации/цикла. Возьмём в качестве примера скетч Blinky.

В setup() функции мы устанавливаем вывод светодиода в положение output. Это нужно сделать только один раз, поскольку эффект от операции остается неизменным до тех пор, пока мы не изменим его дальше, и повторная установка не окажет никакого эффекта, кроме первого (такая операция называется идемпотентной операцией). Но для того, чтобы мигать светодиодом, нам нужно включать и выключать его в цикле с некоторой конечной задержкой между каждой операцией. Мы знаем, как записать это внутри loop() функции. Мы пишем инструкции для включения и выключения светодиода с delay() вызовами между ними.

Всё хорошо. Но что, если нам нужно мигать двумя или более светодиодами с разной частотой? Вы наверняка хотя бы раз задумывались об этом. Если вы попытаетесь использовать функцию delay() для добавления разной частоты, это нарушит логику синхронизации, и вы не добьётесь того, что пытаетесь реализовать. Так в чём же решение? Один из способов — использовать функцию millis() . Она возвращает значение счётчика, которое представляет собой количество миллисекунд, прошедших с момента запуска. Мы можем проверить текущее значение функции millis() и решить, когда включать или выключать несколько светодиодов. Но мы ведь только усложнили программу, верно? Что, если нам нужно будет написать множество задач, помимо простого мигания светодиодов? Программа станет слишком сложной, прежде чем вы успеете это осознать.

Итак, каково лучшее решение? Одним из решений является форма абстракции, называемая многозадачностью, при которой несколько задач выполняются одновременно, как если бы они были отдельными loop() функциями. Если бы у вас было две loop() функции, вы могли бы добиться правильного мигания двух светодиодов с разной частотой, без накладных расходов на использование millis(). Вот что параллельное программирование может сделать для нас. Это абстрагирует от всего сложного и позволяет нам писать код приложения, не беспокоясь о том, что одна задача мешает другой

> Многозадачность, многопроцессорность и многопоточность
> 
> Да, все эти термины похожи и могут сбивать с толку. Обозначают ли они одно и то же? Зависит от того, когда и где вы спросите. Многозадачность обычно означает, когда пользователь запускает несколько приложений (высокоуровневые пользовательские задачи) одновременно вместо того, чтобы открывать и закрывать каждое приложение одновременно. Приложения могут работать на одном или нескольких ядрах. Многопроцессорность означает, когда одно приложение запускает несколько процессов, каждый из которых выполняет разные операции. Процессы могут использовать одно ядро или несколько ядер. Наконец, многопоточность означает, когда вы запускаете один и тот же процесс в нескольких экземплярах, каждый из которых называется “потоком”, для ускорения всего процесса.
> 
> В этом руководстве мы будем придерживаться терминов задача и многозадачность. Задача относится к отдельной функции, выполняющей некоторую операцию. Многозадачность означает совместное выполнение нескольких задач либо на одном ядре, либо на нескольких ядрах.
> 

Существует несколько способов достижения многозадачности в зависимости от среды выполнения. При наличии только одного процессорного ядра мы можем выполнять задачи либо в режиме вытеснения, либо в режиме сотрудничества. Это два из множества методов. При упреждающей многозадачности текущая задача останавливается через определенный интервал, чтобы позволить следующей задаче выполняться с чередованием. Количество задач, их приоритеты и значение временного интервала определяют, насколько плавно могут выполняться ваши параллельные задачи. Если нужно выполнить слишком много задач, это замедлит выполнение всех задач. Возможно, вам знакомо это ощущение, когда вы пытаетесь запустить слишком много приложений одновременно и всё зависает.

С другой стороны, кооперативная многозадачность позволяет каждой задаче выполняться в своё время, пока все остальные задачи ожидают своей очереди на выполнение. Если выполнение задач не занимает много времени, то всё идёт гладко. Но если выполнение какой-либо задачи занимает больше ожидаемого времени, все остальные задачи будут задержаны, и вы заметите задержку в выполнении. Как программист, реализующий логику, вы не хотите, чтобы ваши задачи задерживались по какой-либо причине.

SoC ESP32 имеет два процессорных ядра (на самом деле три, если считать ядро ULP). Большинство современных процессоров имеют несколько ядер на одном кристалле. Если у нас есть несколько ядер, то мы можем указать процессору выполнять наши задачи на разных ядрах, тем самым достигая истинного параллелизма. Даже если одно ядро зависнет, все остальные ядра будут работать нормально. Это называется параллельным выполнением. Можно представить, что у нас есть несколько независимых loop() функций. Мы увидим, как мы можем писать параллельные задачи на следующем шаге.

### Написание параллельных задач

Добавить новую задачу, которая будет выполняться параллельно с другими задачами, очень просто. Попробуйте загрузить следующий код на плату ESP32. Мы используем DOIT ESP32 DEVKIT V1.

### Библиография

#### [Использование семафоров и мьютексов в FreeRTOS на Arduino Uno](https://microkontroller.ru/arduino-projects/ispolzovanie-semaforov-i-myuteksov-v-freertos-na-arduino-uno/)

###### [в начало](#kvizzy)

0

1

2

3

4

5

6

7

8

9

0

1

2

3

4

5




