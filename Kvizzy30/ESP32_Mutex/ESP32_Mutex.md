## [ESP32_Mutex 5.3.1]() 

### [Как писать параллельные многозадачные приложения для ESP32 с использованием FreeRTOS и Arduino](https://www.circuitstate.com/tutorials/how-to-write-parallel-multitasking-applications-for-esp32-using-freertos-arduino/)

Узнайте, как воспользоваться преимуществами многозадачности FreeRTOS для двухъядерной SoC ESP32, используя вашу любимую Arduino IDE. Воспользуйтесь нашими примерами, чтобы узнать о мьютексе, семафоре и коде критической секции.

ESP32 — это мощный и многофункциональный SoC от Espressif. Он, несомненно, является одним из наших любимых. Одна из причин, по которой он нам так нравится, заключается в том, что это двухъядерный SoC с высокой тактовой частотой и большим объёмом памяти. Два ядра означают, что внутри кристалла SoC находятся два отдельных процессора. Чтобы в полной мере воспользоваться этими потрясающими аппаратными функциями, обычного метода последовательного программирования недостаточно. Последовательное программирование или выполнение — это когда одна задача выполняется, а все остальные задачи ожидают завершения выполняемой задачи. Напротив, если вы думаете о своём персональном компьютере, то знаете, что можете выполнять несколько задач одновременно, как если бы каждая задача/приложение выполнялись параллельно и независимо друг от друга. Хотя последовательное программирование может это обеспечить, если выполняется достаточно быстро, есть реальные преимущества в использовании «истинного параллелизма» с несколькими ядрами. К счастью, мы можем писать настоящие параллельные приложения для ESP32 в среде Arduino благодаря отличной поддержке инженеров Espressif. Для этого вам не нужно ничего устанавливать. Это уже есть в среде Arduino, и вы сознательно или бессознательно использовали это, если когда-либо работали с ESP32. В этом руководстве мы научимся правильно писать параллельные задачи для ESP32 с помощью FreeRTOS и Arduino Development Framework (ADF).

Если вы новичок в работе с ESP32, у нас есть отличное руководство по началу работы, в котором мы используем плату DOIT ESP32 DevKit V1 для демонстрации.

#### Последовательное или параллельное программирование

Это сложная тема в области компьютерных наук, и мы не будем рассматривать её полностью. Вместо этого мы ограничимся деталями, достаточными для понимания концепции и целей этого руководства. Мы будем использовать знакомые примеры и по возможности среду Arduino. Мы знаем, что в базовой программе Arduino есть как минимум две функции: setup() и loop(). Эти функции представляют собой две логические конструкции, которые помогают нам реализовать логику нашей прикладной программы. Функция setup() запускается только один раз после включения питания и инициализирует все необходимые нам контакты и интерфейсы. Функция loop() с другой стороны может содержать последовательность инструкций, которая будет перезапускаться после завершения итерации/цикла. Возьмём в качестве примера скетч Blinky.

В setup() функции мы устанавливаем вывод светодиода в положение output. Это нужно сделать только один раз, поскольку эффект от операции остается неизменным до тех пор, пока мы не изменим его дальше, и повторная установка не окажет никакого эффекта, кроме первого (такая операция называется идемпотентной операцией). Но для того, чтобы мигать светодиодом, нам нужно включать и выключать его в цикле с некоторой конечной задержкой между каждой операцией. Мы знаем, как записать это внутри loop() функции. Мы пишем инструкции для включения и выключения светодиода с delay() вызовами между ними.

Всё хорошо. Но что, если нам нужно мигать двумя или более светодиодами с разной частотой? Вы наверняка хотя бы раз задумывались об этом. Если вы попытаетесь использовать функцию delay() для добавления разной частоты, это нарушит логику синхронизации, и вы не добьётесь того, что пытаетесь реализовать. Так в чём же решение? Один из способов — использовать функцию millis() . Она возвращает значение счётчика, которое представляет собой количество миллисекунд, прошедших с момента запуска. Мы можем проверить текущее значение функции millis() и решить, когда включать или выключать несколько светодиодов. Но мы ведь только усложнили программу, верно? Что, если нам нужно будет написать множество задач, помимо простого мигания светодиодов? Программа станет слишком сложной, прежде чем вы успеете это осознать.

Итак, каково лучшее решение? Одним из решений является форма абстракции, называемая многозадачностью, при которой несколько задач выполняются одновременно, как если бы они были отдельными loop() функциями. Если бы у вас было две loop() функции, вы могли бы добиться правильного мигания двух светодиодов с разной частотой, без накладных расходов на использование millis(). Вот что параллельное программирование может сделать для нас. Это абстрагирует от всего сложного и позволяет нам писать код приложения, не беспокоясь о том, что одна задача мешает другой

> Многозадачность, многопроцессорность и многопоточность
> 
> Да, все эти термины похожи и могут сбивать с толку. Обозначают ли они одно и то же? Зависит от того, когда и где вы спросите. Многозадачность обычно означает, когда пользователь запускает несколько приложений (высокоуровневые пользовательские задачи) одновременно вместо того, чтобы открывать и закрывать каждое приложение одновременно. Приложения могут работать на одном или нескольких ядрах. Многопроцессорность означает, когда одно приложение запускает несколько процессов, каждый из которых выполняет разные операции. Процессы могут использовать одно ядро или несколько ядер. Наконец, многопоточность означает, когда вы запускаете один и тот же процесс в нескольких экземплярах, каждый из которых называется “потоком”, для ускорения всего процесса.
> 
> В этом руководстве мы будем придерживаться терминов задача и многозадачность. Задача относится к отдельной функции, выполняющей некоторую операцию. Многозадачность означает совместное выполнение нескольких задач либо на одном ядре, либо на нескольких ядрах.
> 

Существует несколько способов достижения многозадачности в зависимости от среды выполнения. При наличии только одного процессорного ядра мы можем выполнять задачи либо в режиме вытеснения, либо в режиме сотрудничества. Это два из множества методов. При упреждающей многозадачности текущая задача останавливается через определенный интервал, чтобы позволить следующей задаче выполняться с чередованием. Количество задач, их приоритеты и значение временного интервала определяют, насколько плавно могут выполняться ваши параллельные задачи. Если нужно выполнить слишком много задач, это замедлит выполнение всех задач. Возможно, вам знакомо это ощущение, когда вы пытаетесь запустить слишком много приложений одновременно и всё зависает.

С другой стороны, кооперативная многозадачность позволяет каждой задаче выполняться в своё время, пока все остальные задачи ожидают своей очереди на выполнение. Если выполнение задач не занимает много времени, то всё идёт гладко. Но если выполнение какой-либо задачи занимает больше ожидаемого времени, все остальные задачи будут задержаны, и вы заметите задержку в выполнении. Как программист, реализующий логику, вы не хотите, чтобы ваши задачи задерживались по какой-либо причине.

SoC ESP32 имеет два процессорных ядра (на самом деле три, если считать ядро ULP). Большинство современных процессоров имеют несколько ядер на одном кристалле. Если у нас есть несколько ядер, то мы можем указать процессору выполнять наши задачи на разных ядрах, тем самым достигая истинного параллелизма. Даже если одно ядро зависнет, все остальные ядра будут работать нормально. Это называется параллельным выполнением. Можно представить, что у нас есть несколько независимых loop() функций. Мы увидим, как мы можем писать параллельные задачи на следующем шаге.

#### Написание параллельных задач

Добавить новую задачу, которая будет выполняться параллельно с другими задачами, очень просто. Попробуйте загрузить следующий код на плату ESP32. Мы используем DOIT ESP32 DEVKIT V1.

#### [Базовый пример параллельной работы двух задач в ESP32 board 5.1.33  (на контроллере AI-Thinker ESP32-CAM)](ex5-1-33_twousoneBlink/ex5-1-33_twousoneBlink.ino)

При выполнении программы вы можете видеть, как светодиод мигает каждую секунду, и в то же время на последовательном мониторе выводится строка «Привет, мир!». Теперь, если вы измените значения задержки loop() и loop2() на любые другие, вы увидите, что изменения, внесённые в одну задачу, не влияют на другую задачу. По сути, мы добились параллелизма. Этого небольшого примера достаточно, чтобы вы могли реализовать сложные параллельные приложения. Но есть несколько моментов, о которых следует помнить.

Вы можете видеть, что функция loop2() имеет единственный вызываемый аргумент, void* pvParameters который мы даже нигде внутри функции не используем. Эта часть аргумента обязательна для любой функции, которая будет выполняться как задача. Параметр представляет собой тип void указателя с именем pvParameters. Это название не обязательно должно быть одинаковым, оно может быть любым. Но для наглядности оставьте название как есть. Тип возвращаемого значения функции задачи всегда должен быть void. В противном случае это приведет к ошибке компиляции. Если вам интересно, почему у loop() функции по умолчанию нет никаких аргументов, это потому, что функция по умолчанию loop() автоматически инкапсулируется препроцессором (приложением, которое сканирует и перестраивает ваш код) перед его компиляцией.

Следует также отметить наличие цикла while внутри loop2(). Когда мы преобразуем функцию в задачу, мы просим операционную систему только запустить её, а не выполнять многократно. Поэтому нам нужен бесконечный цикл внутри функции loop2(). Без цикла while задача loop2() будет выполнена только один раз. Причина, по которой loop() по умолчанию не содержит такого цикла, заключается в том, что среда Arduino уже управляет им.

#### Какое ядро использовать?

Поскольку у нас есть два ядра, вы можете задуматься о том, какое ядро использовать для своих задач. Одно ядро лучше другого? Что ж, как мы уже говорили, каждое ядро — это, по сути, отдельный процессор. Каждый процессор может выполнять инструкции параллельно, но совместно использовать общие ресурсы, такие как память и периферийные устройства. По умолчанию весь ваш код Arduino работает на ядре 1, а функции Wi-Fi и радиочастот (обычно скрытые в среде Arduino) используют ядро 0. Чтобы узнать, на каком ядре выполняется ваша текущая задача, вы можете использовать функцию ***xPortGetCoreID()***.

```
#define LED_BUILTIN 33
// the setup function runs once when you press reset or power the board
void setup() {
  // initialize digital pin LED_BUILTIN as an output.
  pinMode (LED_BUILTIN, OUTPUT);

  Serial.begin (115200);

  xTaskCreatePinnedToCore (
    loop2,     // Function to implement the task
    "loop2",   // Name of the task
    1000,      // Stack size in words
    NULL,      // Task input parameter
    0,         // Priority of the task
    NULL,      // Task handle.
    0          // Core where the task should run
  );
}

// the loop function runs over and over again forever
void loop() {
  digitalWrite (LED_BUILTIN, HIGH);  // turn the LED on (HIGH is the voltage level)
  delay (1000);  // wait for a second
  digitalWrite (LED_BUILTIN, LOW); // turn the LED off by making the voltage LOW
  delay (1000);  // wait for a second
  Serial.print ("loop() running in core ");
  Serial.println (xPortGetCoreID());
}

// the loop2 function also runs forver but as a parallel task
void loop2 (void* pvParameters) {
  while (1) {
    Serial.print ("Hello");
    delay (500); // wait for half a second
    Serial.print (" World from loop2() at ");
    Serial.println (xPortGetCoreID());
    delay (500); // wait for half a second
  }
}
```
При этом будет выведен идентификатор ядра, на котором выполняются функции. Решение о том, какое ядро использовать, зависит от того, какая часть рабочей нагрузки выполняется на этом ядре. Для работы с радиочастотами на ESP32 SoC требуется программное обеспечение, чувствительное ко времени и основанное на прерываниях, которое может быть сложным. Поскольку ядро 0 уже используется для этих задач, всегда лучше использовать второе ядро 1. Но это применимо только в том случае, если вы используете некоторые функции радиочастот, такие как Wi-Fi или BLE. Если вам не нужны какие-либо функции, выберите те ядра, которые вам нравятся.

В нашем примере вы можете попробовать изменить ядро с loop2() на 1 . Это позволит loop() и loop2() работать на одном ядре. В этом случае наши задачи станут не параллельными, а одновременными. Но как это работает? Чтобы понять это, нам нужно немного узнать о FreeRTOS.

#### Совместное использование ресурсов

Сейчас самое подходящее время взглянуть на внутреннюю блок-схему SoC ESP32. 

![Внутренняя блок-схема ESP32. Источник: Espressif](Espressif-ESP32-Internal-Block-Diagram-CIRCUITSTATE-Electronics-01.png)

Как вы можете видеть, их два (по 1 для некоторых вариантов). 32-разрядные микропроцессорные ядра Xtensa LX6 внутри SoC. Но все остальные ресурсы являются общими. Например, оба ядра используют одно и то же пространство ROM и SRAM. Это также верно для других периферийных устройств. Оба ядра могут обращаться к любым периферийным устройствам, к которым захотят. Но если это так, то не возникнут ли конфликты, если одно ядро попытается выполнить какую-то операцию с одним периферийным устройством, а другое ядро попытается сделать что-то еще с тем же самым? Да, такая ситуация может возникнуть в многоядерной среде. По этой причине вы как программист несете ответственность за написание бесконфликтного кода при разработке приложений, требующих параллельных задач, выполняемых на нескольких ядрах. Однако не останавливайтесь. Существует достаточно инструментов и методик, которые помогут вам написать чистый и эффективный код для ваших многозадачных приложений.

Одним из примеров конфликта при совместном использовании ресурсов в многоядерной среде является состояние гонки, возникающее при доступе к памяти. Предположим, у нас есть ячейка памяти с адресом 0xF00. Мы можем написать две параллельные задачи; обе они будут пытаться записать случайное число в это место и прочитать его позже. Итак, что происходит, когда одна задача записывает значение, и в то же время другая задача также пытается сделать то же самое? Какая задача получает возможность записи в ячейку памяти? Ответ не определен. Это означает, что мы не можем предсказать, какая из задач получит запись в ячейку памяти, потому что они обе стремятся достичь одного и того же.

Условия гонки приводят к появлению странных ошибок, которые могут не обнаруживаться при обычном тестировании. Поэтому всякий раз, когда вам нужно разделить переменную, объект, функцию или периферийное устройство между задачами, убедитесь, что только одна задача обращается к ресурсу одновременно. Задача доступа также должна оставлять ресурс в определенном состоянии после выполнения операции. Но как мы это делаем? Прочитайте об этом в следующем разделе.

#### Синхронизация задач

Всякий раз, когда нам нужно поделиться ресурсом или заставить две задачи / процессы взаимодействовать друг с другом, нам нужен механизм, предотвращающий одновременный доступ обеих задач к ресурсу и его изменение. Когда задача обращается к ресурсу, нам нужно сообщить всем другим задачам, что ресурс используется в данный момент. Это называется синхронизацией задач. Для достижения этой цели есть два метода; Мьютекс и семафор. Мьютекс расшифровывается как “Взаимное исключение”. Мьютекс - это просто общая переменная, доступ к которой всегда осуществляется с помощью атомарных операций. Что такое атомарная операция, спросите вы? Это способ выполнения последовательности инструкций без каких-либо прерываний операции до ее завершения. Переменная мьютекса может оставаться в двух состояниях; заблокирована и разблокирована (0 или 1). Вы можете рассматривать это как логическую переменную. Оно используется для защиты общего ресурса от одновременного доступа нескольких задач. Процесс / задача может получить блокировку мьютекса, вызвав функцию с именем acquire(). После получения блокировки задача может продолжить работу с объектом, защищенным мьютексом, не беспокоясь о том, что другие задачи изменят ресурс. Если какие-либо другие задачи попытаются получить блокировку мьютекса, когда он уже заблокирован, запрашивающие задачи перейдут в состояние ожидания, называемое занятым ожиданием. Процессы, пытающиеся получить блокировку, будут многократно пытаться получить ее, пока не добьются успеха. Занятое ожидание также называется спин-блокировкой.

![Иллюстрация функциональности мьютекса](How-to-Write-Parallel-Multitasking-Applications-for-ESP32-with-FreeRTOS-and-Arduino-Mutex-Working-Illustration-CIRCUITSTATE-Electronics-01-1280x751.png)

Задача, которая изначально получила блокировку, освободит её, когда завершит все свои операции. Освободить блокировку мьютекса можно с помощью release(). Теперь другие задачи, ожидающие получения блокировки, могут получить её.acquire() и release() — это общие названия функций, используемые для объяснения концепции, а фактические названия могут зависеть от платформы.

Другой тип синхронизации задач называется семафором и представляет собой метод передачи сигналов. Разница между семафором и мьютексом заключается в том, что семафор действует как сигнал, например, световая индикация, а мьютекс — это блокировка, аналогичная навесному замку с ключом. Семафор также является переменной, совместно используемой задачами. Но в отличие от мьютексов, он может находиться в более чем двух состояниях. Семафоры реализуются двумя способами: счётные семафоры и двоичные семафоры. Семафор-счётчик — это целочисленная переменная, значение которой инициализируется количеством экземпляров определённого ресурса, доступ к которому осуществляется совместно. Например, если у вас есть 10 экземпляров структуры данных, то семафор инициализируется значением 10. Это означает, что все 10 структур в начале свободны. Затем задача может запросить один экземпляр этих данных и уменьшить значение переменной семафора. Значение семафора станет равным 9. Когда все экземпляры заняты задачами, семафор становится равным 0. Когда задача завершает использование ресурса, она может освободить ресурс и увеличить семафор на 1. Если задача запрашивает доступ, когда семафор равен 0, она может либо подождать, пока не освободится хотя бы один ресурс, либо выполнить некоторые другие операции, не тратя время на ожидание.

![Пример семафора. Несколько задач пытаются получить доступ к трём экземплярам ресурса. Доступ получают только первые три задачи, а остальные находятся в состоянии ожидания](How-to-Write-Parallel-Multitasking-Applications-for-ESP32-with-FreeRTOS-and-Arduino-Semaphore-Working-Illustration-CIRCUITSTATE-Electronics-01-1280x556.png)

Двоичный семафор, как следует из названия, может принимать только одно значение или находиться в одном из двух состояний (0 и 1). Разница между двоичным семафором и мьютексом заключается в том, что двоичный семафор служит только для передачи сигнала о том, используется ресурс или нет, а мьютекс блокирует ресурс для других задач. Оба варианта имеют разные области применения. Если вы запутались, давайте вкратце рассмотрим концепции мьютекса и семафора.

Мьютекс — это блокировка взаимного исключения, которая используется, когда несколько задач конкурируют за один ресурс.
Мьютекс может находиться только в двух состояниях; заблокирован и разблокирован.
Мьютекс заставляет запрашивающие задачи “вращаться” (ожидание занятости) до тех пор, пока не будет доступен ресурс.
Семафор — это метод передачи сигналов. Задачи могут свободно заниматься чем-то другим, не тратя время на ожидание.
Семафоры могут находиться в N состояниях, и максимальное значение указывает на общее количество доступных ресурсов.
Семафоры отслеживают использование ресурсов и хорошо подходят для данных, которые можно разделить или использовать в нескольких экземплярах.
Семафор не предоставляет исключительный доступ к ресурсу, а вместо этого предоставляет доступ к одному из множества экземпляров ресурса.
Двоичный семафор указывает на доступность только одного экземпляра ресурса.








### Библиография

#### [Использование семафоров и мьютексов в FreeRTOS на Arduino Uno](https://microkontroller.ru/arduino-projects/ispolzovanie-semaforov-i-myuteksov-v-freertos-na-arduino-uno/)

###### [в начало](#kvizzy)

0

1

2

3

4

5

6

7

8

9

0

1

2

3

4

5




